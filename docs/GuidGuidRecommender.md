
# Overview

The GUID-GUID coinstallation recommender system generates recommendations
for add-ons which are similar to a given add-on,
where similarity is based on the number of profiles
which have both add-ons installed.

As recommendations are only surfaced
for a specific set of add-ons meeting certain criteria,
and depend only on characteristics of the add-ons themselves,
recommendation sets for each add-on can be (and are) computed in advance.

Recommendations are generated as follows:

1. The [input data](#input-data),
    consisting of coinstallation counts for each pair of add-ons,
    is loaded from a precomputed file.
2. For each add-on, we determine a [__candidate list__](#generating-the-scored-candidate-lists) of "related" add-ons,
    together with associated __relevance scores__,
    based on the coinstallation data.
3. Recommendations for a given add-on are [selected](#selecting-recommendations)
    by retaining the N add-ons in the candidate list
    with the highest relevance scores.

Once the recommender has been trained,
we apply various [metrics](#quality-and-health-metrics)
to the coinstallation data, candidate lists, and recommendations,
to evaluate the overall health of the system
and the quality of recommendations.


# Input data

The primary data source used in generating recommendations
is the file `guid_coinstallation.json`,
which is generated by the ETL jobs described in the [README](../README.md).
It contains coinstallation counts for each pair of add-ons
belonging to a filtered list.

Coinstallation counts are computed based on the Telemetry data
submitted by a random sample of recently active Firefox profiles.
For each pair of add-ons in the list,
we count the number of profiles in which both add-ons are installed and enabled.

The data is stored in "sparse matrix representation" as a nested object/dict,
in which each add-on GUID maps to a further object
mapping coinstalled GUIDS to their coinstallation count,
dropping zero counts.
On initializing a [`GuidGuidCoinstallRecommender`](../taar_lite/recommenders/guidguid.py#L10),
it is supplied as `raw_coinstall_dict`.

Using this dataset as the basis for recommendations
entails the following assumptions:

- The set of add-ons appearing in the coinstallation dataset represent
    the universe of known add-ons for the purpose of generating recommendations.
- We are only dealing with add-ons that were coinstalled
    with at least one other add-on on the list
    (otherwise they would not appear in the file at all).
- Profiles with only a single add-on installed do not contribute to the counts.

__TODO:__ How are system add-ons handled? Add a note about this.

In computing relevance scores, we also draw on an auxiliary dataset
containing an overall ranking for each add-on in our list,
read from the file `guid_install_ranking.json`.
This is used to break ties when sorting candidates on relevance score,
and in pruning out rare add-ons.
It is currently computed from overall add-on installation counts
obtained from AMO.

This data is stored as an object/dict mapping add-on GUIDs to rank scores.
On initializing a [`GuidGuidCoinstallRecommender`](../taar_lite/recommenders/guidguid.py#L10),
it is supplied as `tie_breaker_dict`.
It is also used as the `ranking_dict` passed to the [`MinInstallPrune`](../taar_lite/recommenders/treatments.py#L36) treatment.


# Generating the scored candidate lists

The TAAR-lite recommender is built on the following underlying principle:
_add-ons which tend to be installed together are similar or complimentary,
and the number of coinstallations indicates the strength of this relationship._
Thus, starting from a given add-on, good recommendations for other add-ons
are those which are most often coinstalled.

Given an add-on A, a natural choice for a candidate list and relevance scores
is then just the list of add-ons that are coinstalled with A,
together with their coinstallation counts.
However, recommendation quality can be improved by making certain adjustments
to these preliminary scored lists, such as:

- tempering the influence of highly popular add-ons
    so that they don't drown out more relevant, less common ones
- pruning out obscure add-ons
- better balancing relevance against diversity
- improving the experience for users clicking through a chain of recommendations
    on AMO, such as pruning out cyclical recommendations.

Final candidate lists and relevance scores are generated
by applying a sequence of such transformations,
referred to as [__treatments__](#treatments),
to the raw coinstallation data.
As recommendations are based solely on the treated data,
we are assuming that it encapsulates all the information
necessary in generating recommendations.

Treatments are implemented as extensions of the [`BaseTreatment`](../taar_lite/recommenders/treatments.py#L11) class,
which apply a transformation via the `treat()` method.
On initializing a [`GuidGuidCoinstallRecommender`](../taar_lite/recommenders/guidguid.py#L10),
a list of `BaseTreatment` instances are supplied as `treatments`.
When the treated dataset is built, the treatments are applied in sequence
to the raw coinstallation data,
and the result is stored as the recommender instance's `treated_graph`.
Candidate lists and relevance scores are then drawn
from the treated dataset.


## Graph representation

It is helpful to discuss candidate lists, relevance scores and treatments
in terms of of an __add-on relational graph__ structure,
as much of the intuition behind the treatments
is drawn from this representation.

An add-on relational graph is a directed graph $G$ in which:

- each vertex is an add-on appearing in the dataset
- there is an edge from A to B if add-on B is considered _related_ to add-on A
- each edge has an associated weight
    indicating the strength of the relationship.

The data used in generating recommendations can be summarized
by such a graph, where
an add-on's candidate list corresponds to its set of neighbours in the graph,
and relevance scores are given by the edge weights.
A relational graph is induced directly by the coinstallation data,
considering add-ons related if they are coinstalled,
and using coinstallation counts as weights.
Treatments can be thought of as transformations
which modify add-on relational graphs by
adding or deleting edges, or adjusting the edge weights.

Note that, since the graph is directed, edges do not necessarily run both ways.
In other words, we allow for a treatment to produce a graph in which
A is related to B but B is not related to A,
for example if it removes edges whose weight falls below a threshold.
However, since the relation of being coinstalled is symmetric,
the initial coinstallation graph is undirected.

A relational graph has an associated __adjacency matrix__ $C$,
in which rows and columns are indexed by add-ons (graph vertices),
and entry $C_{ij}$ contains the weight for edge $(i,j)$
if these two add-ons are connected in the graph, or 0 otherwise.

The initial coinstallation dataset is in fact stored
as a sparse representation of its adjacency matrix.
Since this graph is undirected, the adjacency matrix is symmetric
($C_{ij} = C_{ji}$ for any pair $i,j$).
Also, the row sum (or column sum, by symmetry) for add-on $i$ gives
its overall number of installs across all profiles considered in the dataset.


## Treatments



# Selecting recommendations

Recommendations for a given add-on A are generated
by ordering A's candidate list by decreasing relevance score
and selecting the first N add-ons from the sorted list.
Ties in relevance score are broken using an additional list
of add-on tie-breaking scores,
by further ordering tied candidates by decreasing tie-breaking score.

Recommendations are requested from a `GuidGuidCoinstallRecommender` instance
using the [`recommend()`](taar_lite/recommenders/guidguid.py#L123) method.
The list of tie-breaking scores was supplied on initialization as `tie_breaker_dict`.
The double ordering is currently implemented by concatenating the two scores
and applying lexicographical ordering on the result.

The version of the GUID-GUID recommender currently in production
defaults to requesting 4 recommendations for each add-on,
which corresponds to the number of display slots on AMO.

__TODO:__ this method of selecting recommendations can be viewed as just another treatment.


# Quality and health metrics

